{"version":3,"sources":["../node_modules/react-aria-modal/dist/react-aria-modal.js","../node_modules/focus-trap-react/dist/focus-trap-react.js","../node_modules/react-displace/dist/displace.js","../node_modules/no-scroll/index.js","../../src/index.js","../../index.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_possibleConstructorReturn","self","call","_assertThisInitialized","ReferenceError","_getPrototypeOf","getPrototypeOf","_defineProperty","value","React","require","FocusTrap","displace","noScroll","Modal","_React$Component","subClass","superClass","TypeError","create","_inherits","Constructor","protoProps","staticProps","_super","Derived","isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","e","result","Super","NewTarget","this","arguments","apply","_createSuper2","_this","instance","_classCallCheck","getApplicationNode","applicationNode","event","dialogNode","contains","pageX","ownerDocument","documentElement","offsetWidth","pageY","offsetHeight","exit","escapeExits","keyCode","onExit","titleText","titleId","Error","onEnter","setTimeout","setAttribute","addKeyDownListener","scrollDisabled","on","prevProps","off","removeKeyDownListener","_this2","document","addEventListener","checkDocumentKeyDown","_this3","removeEventListener","style","includeDefaultStyles","position","top","left","width","height","zIndex","overflowX","overflowY","WebkitOverflowScrolling","textAlign","underlayColor","background","underlayClickExits","cursor","underlayStyle","hasOwnProperty","underlayProps","className","underlayClass","prop","onMouseDown","checkUnderlayClick","verticalCenterStyle","display","verticalAlign","verticalCenterHelperProps","dialogStyle","maxWidth","outline","focusDialog","verticallyCenter","_key","dialogProps","ref","el","bind","role","alert","id","dialogId","dialogClass","_key2","tabIndex","test","childrenArray","createElement","children","unshift","focusTrapOptions","initialFocus","concat","escapeDeactivates","paused","focusTrapPaused","Component","DisplacedModal","renderTo","input","module","exports","_createSuper","hasNativeReflectConstruct","Boolean","valueOf","_isNativeReflectConstruct","ReactDOM","PropTypes","createFocusTrap","tailoredFocusTrapOptions","returnFocusOnDeactivate","optionName","onPostDeactivate","focusTrapElements","containerElements","updatePreviousElement","optionValue","node","querySelector","getNodeForOption","previouslyFocusedElement","currentDocument","undefined","activeElement","_this$tailoredFocusTr","checkCanReturnFocus","_this$tailoredFocusTr2","preventScroll","focusTrap","deactivate","returnFocus","finishDeactivation","returnFocusNode","getReturnFocusNode","focus","then","focusTrapElementDOMNodes","map","findDOMNode","some","_createFocusTrap","active","activate","pause","setupFocusTrap","updateContainerElements","hasActivated","hasDeactivated","hasPaused","hasUnpaused","deactivateTrap","unpause","child","Children","only","type","Fragment","cloneElement","element","current","ElementType","Element","Function","propTypes","bool","shape","object","onActivate","func","onPostActivate","checkCanFocusTrap","onDeactivate","oneOfType","instanceOf","string","fallbackFocus","clickOutsideDeactivates","setReturnFocus","allowOutsideClick","arrayOf","defaultProps","_createClass","defineProperties","canUsePortals","createPortal","WrappedComponent","options","global","EmptyDisplace","Displaced","_React$Component2","_ref","_temp","_len","args","Array","renderDisplaced","unstable_renderSubtreeIntoContainer","container","removeDisplaced","unmountComponentAtNode","body","appendChild","mounted","parentNode","removeChild","root","scrollbarSize","scrollTop","isOn","doc","window","pageYOffset","scrollHeight","innerHeight","dummyScroller","clientWidth","getScrollbarSize","overflow","scroll","toggle","candidateSelectors","candidateSelector","matches","getCandidates","candidates","includeContainer","getTabindex","tabindexAttr","parseInt","isNaN","isContentEditable","sortOrderedTabbables","a","b","isInput","isNonTabbableRadio","isRadio","radioScope","queryRadios","name","radioSet","err","console","checked","nodes","getCheckedRadio","isTabbableRadio","isNodeMatchingSelectorFocusable","isHiddenInput","getComputedStyle","nodeUnderDetails","displayCheck","isHidden","isDetailsWithSummary","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","focusableCandidateSelector","isFocusable","activeFocusTraps","trapQueue","activateTrap","activeTrap","trapIndex","delay","fn","findIndex","idx","arr","valueOrHandler","params","getActualTarget","userOptions","config","delayInitialFocus","state","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","delayInitialFocusTimer","getOption","configOverrideOptions","configOptionName","containersContain","getInitialFocusNode","firstTabbableGroup","updateTabbableNodes","tabbableNodes","regularTabbables","orderedTabbables","candidate","candidateTabindex","documentOrder","tabbable","firstTabbableNode","lastTabbableNode","tryFocus","isSelectableInput","checkPointerDown","trap","checkFocusIn","targetContained","checkKey","isEscapeEvent","isTabEvent","destinationNode","containerIndex","startOfGroupIndex","destinationGroupIndex","lastOfGroupIndex","checkTab","checkClick","addListeners","capture","passive","removeListeners","activateOptions","finishActivation","clearTimeout","deactivateOptions","elementsAsArray","filter"],"mappings":"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","file":"static/js/3.8380a5dd.chunk.js","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper2(Derived) {\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar React = require('react');\n\nvar FocusTrap = require('focus-trap-react');\n\nvar displace = require('react-displace');\n\nvar noScroll = require('no-scroll');\n\nvar Modal =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Modal, _React$Component);\n\n  var _super = _createSuper2(Modal);\n\n  function Modal(props) {\n    var _this;\n\n    _classCallCheck(this, Modal);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"getApplicationNode\", function () {\n      if (_this.props.getApplicationNode) return _this.props.getApplicationNode();\n      return _this.props.applicationNode;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"checkUnderlayClick\", function (event) {\n      if (_this.dialogNode && _this.dialogNode.contains(event.target) || // If the click is on the scrollbar we don't want to close the modal.\n      event.pageX > event.target.ownerDocument.documentElement.offsetWidth || event.pageY > event.target.ownerDocument.documentElement.offsetHeight) return;\n\n      _this.exit(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"checkDocumentKeyDown\", function (event) {\n      if (_this.props.escapeExits && (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27)) {\n        _this.exit(event);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"exit\", function (event) {\n      if (_this.props.onExit) {\n        _this.props.onExit(event);\n      }\n    });\n\n    if (!props.titleText && !props.titleId) {\n      throw new Error('react-aria-modal instances should have a `titleText` or `titleId`');\n    }\n\n    return _this;\n  }\n\n  _createClass(Modal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.onEnter) {\n        this.props.onEnter();\n      } // Timeout to ensure this happens *after* focus has moved\n\n\n      var applicationNode = this.getApplicationNode();\n      setTimeout(function () {\n        if (applicationNode) {\n          applicationNode.setAttribute('aria-hidden', 'true');\n        }\n      }, 0);\n\n      if (this.props.escapeExits) {\n        this.addKeyDownListener();\n      }\n\n      if (this.props.scrollDisabled) {\n        noScroll.on();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.scrollDisabled && !this.props.scrollDisabled) {\n        noScroll.off();\n      } else if (!prevProps.scrollDisabled && this.props.scrollDisabled) {\n        noScroll.on();\n      }\n\n      if (this.props.escapeExits && !prevProps.escapeExits) {\n        this.addKeyDownListener();\n      } else if (!this.props.escapeExits && prevProps.escapeExits) {\n        this.removeKeyDownListener();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.scrollDisabled) {\n        noScroll.off();\n      }\n\n      var applicationNode = this.getApplicationNode();\n\n      if (applicationNode) {\n        applicationNode.setAttribute('aria-hidden', 'false');\n      }\n\n      this.removeKeyDownListener();\n    }\n  }, {\n    key: \"addKeyDownListener\",\n    value: function addKeyDownListener() {\n      var _this2 = this;\n\n      setTimeout(function () {\n        document.addEventListener('keydown', _this2.checkDocumentKeyDown);\n      });\n    }\n  }, {\n    key: \"removeKeyDownListener\",\n    value: function removeKeyDownListener() {\n      var _this3 = this;\n\n      setTimeout(function () {\n        document.removeEventListener('keydown', _this3.checkDocumentKeyDown);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      var style = {};\n\n      if (props.includeDefaultStyles) {\n        style = {\n          position: 'fixed',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          zIndex: 1050,\n          overflowX: 'hidden',\n          overflowY: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          textAlign: 'center'\n        };\n\n        if (props.underlayColor) {\n          style.background = props.underlayColor;\n        }\n\n        if (props.underlayClickExits) {\n          style.cursor = 'pointer';\n        }\n      }\n\n      if (props.underlayStyle) {\n        for (var key in props.underlayStyle) {\n          if (!props.underlayStyle.hasOwnProperty(key)) continue;\n          style[key] = props.underlayStyle[key];\n        }\n      }\n\n      var underlayProps = {\n        className: props.underlayClass,\n        style: style\n      };\n\n      if (props.underlayClickExits) {\n        underlayProps.onMouseDown = this.checkUnderlayClick;\n      }\n\n      for (var prop in this.props.underlayProps) {\n        underlayProps[prop] = this.props.underlayProps[prop];\n      }\n\n      var verticalCenterStyle = {};\n\n      if (props.includeDefaultStyles) {\n        verticalCenterStyle = {\n          display: 'inline-block',\n          height: '100%',\n          verticalAlign: 'middle'\n        };\n      }\n\n      var verticalCenterHelperProps = {\n        key: 'a',\n        style: verticalCenterStyle\n      };\n      var dialogStyle = {};\n\n      if (props.includeDefaultStyles) {\n        dialogStyle = {\n          display: 'inline-block',\n          textAlign: 'left',\n          top: 0,\n          maxWidth: '100%',\n          cursor: 'default',\n          outline: props.focusDialog ? 0 : null\n        };\n\n        if (props.verticallyCenter) {\n          dialogStyle.verticalAlign = 'middle';\n          dialogStyle.top = 0;\n        }\n      }\n\n      if (props.dialogStyle) {\n        for (var _key in props.dialogStyle) {\n          if (!props.dialogStyle.hasOwnProperty(_key)) continue;\n          dialogStyle[_key] = props.dialogStyle[_key];\n        }\n      }\n\n      var dialogProps = {\n        key: 'b',\n        ref: function (el) {\n          this.dialogNode = el;\n        }.bind(this),\n        role: props.alert ? 'alertdialog' : 'dialog',\n        id: props.dialogId,\n        className: props.dialogClass,\n        style: dialogStyle\n      };\n\n      if (props.titleId) {\n        dialogProps['aria-labelledby'] = props.titleId;\n      } else if (props.titleText) {\n        dialogProps['aria-label'] = props.titleText;\n      }\n\n      if (props.focusDialog) {\n        dialogProps.tabIndex = '-1';\n      } // Apply data- and aria- attributes passed as props\n\n\n      for (var _key2 in props) {\n        if (/^(data-|aria-)/.test(_key2)) {\n          dialogProps[_key2] = props[_key2];\n        }\n      }\n\n      var childrenArray = [React.createElement('div', dialogProps, props.children)];\n\n      if (props.verticallyCenter) {\n        childrenArray.unshift(React.createElement('div', verticalCenterHelperProps));\n      }\n\n      var focusTrapOptions = props.focusTrapOptions || {};\n\n      if (props.focusDialog || props.initialFocus) {\n        focusTrapOptions.initialFocus = props.focusDialog ? \"#\".concat(this.props.dialogId) : props.initialFocus;\n      }\n\n      focusTrapOptions.escapeDeactivates = props.escapeExits;\n      return React.createElement(FocusTrap, {\n        focusTrapOptions: focusTrapOptions,\n        paused: props.focusTrapPaused\n      }, React.createElement('div', underlayProps, childrenArray));\n    }\n  }]);\n\n  return Modal;\n}(React.Component);\n\n_defineProperty(Modal, \"defaultProps\", {\n  underlayProps: {},\n  dialogId: 'react-aria-modal-dialog',\n  underlayClickExits: true,\n  escapeExits: true,\n  underlayColor: 'rgba(0,0,0,0.5)',\n  includeDefaultStyles: true,\n  focusTrapPaused: false,\n  scrollDisabled: true\n});\n\nvar DisplacedModal = displace(Modal);\n\nDisplacedModal.renderTo = function (input) {\n  return displace(Modal, {\n    renderTo: input\n  });\n};\n\nmodule.exports = DisplacedModal;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar PropTypes = require('prop-types');\n\nvar _require = require('focus-trap'),\n    createFocusTrap = _require.createFocusTrap; // TODO: These issues are related to older React features which we'll likely need\n//  to fix in order to move the code forward to the next major version of React.\n//  @see https://github.com/davidtheclark/focus-trap-react/issues/77\n\n/* eslint-disable react/no-find-dom-node */\n\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props); // We need to hijack the returnFocusOnDeactivate option,\n    // because React can move focus into the element before we arrived at\n    // this lifecycle hook (e.g. with autoFocus inputs). So the component\n    // captures the previouslyFocusedElement in componentWillMount,\n    // then (optionally) returns focus to it in componentWillUnmount.\n\n    _this.tailoredFocusTrapOptions = {\n      returnFocusOnDeactivate: false\n    }; // because of the above, we maintain our own flag for this option, and\n    //  default it to `true` because that's focus-trap's default\n\n    _this.returnFocusOnDeactivate = true;\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate') {\n        _this.returnFocusOnDeactivate = !!focusTrapOptions[optionName];\n        continue;\n      }\n\n      if (optionName === 'onPostDeactivate') {\n        _this.onPostDeactivate = focusTrapOptions[optionName];\n        continue;\n      }\n\n      _this.tailoredFocusTrapOptions[optionName] = focusTrapOptions[optionName];\n    } // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  } // TODO: Need more test coverage for this function\n\n\n  _createClass(FocusTrap, [{\n    key: \"getNodeForOption\",\n    value: function getNodeForOption(optionName) {\n      var optionValue = this.tailoredFocusTrapOptions[optionName];\n\n      if (!optionValue) {\n        return null;\n      }\n\n      var node = optionValue;\n\n      if (typeof optionValue === 'string') {\n        node = document.querySelector(optionValue);\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n        }\n      }\n\n      if (typeof optionValue === 'function') {\n        node = optionValue();\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus');\n      return node ? node : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      var currentDocument = this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      var _this2 = this;\n\n      var _this$tailoredFocusTr = this.tailoredFocusTrapOptions,\n          checkCanReturnFocus = _this$tailoredFocusTr.checkCanReturnFocus,\n          _this$tailoredFocusTr2 = _this$tailoredFocusTr.preventScroll,\n          preventScroll = _this$tailoredFocusTr2 === void 0 ? false : _this$tailoredFocusTr2;\n\n      if (this.focusTrap) {\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        this.focusTrap.deactivate({\n          returnFocus: false\n        });\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = (returnFocusNode === null || returnFocusNode === void 0 ? void 0 : returnFocusNode.focus) && _this2.returnFocusOnDeactivate;\n\n        if (canReturnFocus) {\n          /** Returns focus to the element that had focus when the trap was activated. */\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n\n        if (_this2.onPostDeactivate) {\n          _this2.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n      };\n\n      if (checkCanReturnFocus) {\n        checkCanReturnFocus(this.getReturnFocusNode()).then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (!this.focusTrap) {\n        var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return\n        //  a new text node with the text wrapped in it instead of treating the\n        //  string as a selector and resolving it to a node in the DOM\n        ReactDOM.findDOMNode);\n        var nodesExist = focusTrapElementDOMNodes.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.tailoredFocusTrapOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setupFocusTrap();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else if (prevProps.containerElements !== this.props.containerElements) {\n        this.focusTrapElements = this.props.containerElements;\n        this.setupFocusTrap();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var composedRefCallback = function composedRefCallback(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: composedRefCallback\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func, PropTypes.bool]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = require('react');\nvar ReactDOM = require('react-dom');\n\n// React 16+ supports Portals.\nvar canUsePortals = !!ReactDOM.createPortal;\n\nfunction displace(WrappedComponent, options) {\n  if (!global.document) {\n    return function (_React$Component) {\n      _inherits(EmptyDisplace, _React$Component);\n\n      function EmptyDisplace() {\n        _classCallCheck(this, EmptyDisplace);\n\n        return _possibleConstructorReturn(this, (EmptyDisplace.__proto__ || Object.getPrototypeOf(EmptyDisplace)).apply(this, arguments));\n      }\n\n      _createClass(EmptyDisplace, [{\n        key: 'render',\n        value: function render() {\n          return false;\n        }\n      }]);\n\n      return EmptyDisplace;\n    }(React.Component);\n  }\n\n  options = options || {};\n\n  var Displaced = function (_React$Component2) {\n    _inherits(Displaced, _React$Component2);\n\n    function Displaced() {\n      var _ref;\n\n      var _temp, _this2, _ret;\n\n      _classCallCheck(this, Displaced);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_ref = Displaced.__proto__ || Object.getPrototypeOf(Displaced)).call.apply(_ref, [this].concat(args))), _this2), _this2.renderDisplaced = function () {\n        ReactDOM.unstable_renderSubtreeIntoContainer(_this2, React.createElement(WrappedComponent, _this2.props, _this2.props.children), _this2.container);\n      }, _this2.removeDisplaced = function () {\n        ReactDOM.unmountComponentAtNode(_this2.container);\n      }, _temp), _possibleConstructorReturn(_this2, _ret);\n    }\n\n    _createClass(Displaced, [{\n      key: 'componentWillMount',\n      value: function componentWillMount() {\n        this.container = function () {\n          if (!options.renderTo) {\n            var result = document.createElement('div');\n            document.body.appendChild(result);\n            return result;\n          } else if (typeof options.renderTo === 'string') {\n            return document.querySelector(options.renderTo);\n          } else {\n            return options.renderTo;\n          }\n        }();\n      }\n    }, {\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (canUsePortals) return;\n        if (this.props.mounted) {\n          this.renderDisplaced();\n        }\n      }\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate(prevProps) {\n        if (canUsePortals) return;\n        if (prevProps.mounted && !this.props.mounted) {\n          ReactDOM.unmountComponentAtNode(this.container);\n        } else if (this.props.mounted) {\n          this.renderDisplaced();\n        }\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        if (!canUsePortals) {\n          ReactDOM.unmountComponentAtNode(this.container);\n        }\n        if (!options.renderTo) {\n          this.container.parentNode.removeChild(this.container);\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        if (!canUsePortals || this.props.mounted === false) {\n          return null;\n        }\n        return ReactDOM.createPortal(React.createElement(WrappedComponent, this.props, this.props.children), this.container);\n      }\n    }]);\n\n    return Displaced;\n  }(React.Component);\n\n  Displaced.defaultProps = {\n    mounted: true\n  };\n  Displaced.WrappedComponent = WrappedComponent;\n\n\n  return Displaced;\n}\n\nmodule.exports = displace;","(function(root) {\n  var isOn = false;\n  var scrollbarSize;\n  var scrollTop;\n\n  function getScrollbarSize() {\n    if (typeof scrollbarSize !== 'undefined') return scrollbarSize;\n\n    var doc = document.documentElement;\n    var dummyScroller = document.createElement('div');\n    dummyScroller.setAttribute('style', 'width:99px;height:99px;' + 'position:absolute;top:-9999px;overflow:scroll;');\n    doc.appendChild(dummyScroller);\n    scrollbarSize = dummyScroller.offsetWidth - dummyScroller.clientWidth;\n    doc.removeChild(dummyScroller);\n    return scrollbarSize;\n  }\n\n  function hasScrollbar() {\n    return document.documentElement.scrollHeight > window.innerHeight;\n  }\n\n  function on(options) {\n    if (typeof document === 'undefined' || isOn) return;\n    var doc = document.documentElement;\n    scrollTop = window.pageYOffset;\n    if (hasScrollbar()) {\n      doc.style.width = 'calc(100% - '+ getScrollbarSize() +'px)';\n    } else {\n      doc.style.width = '100%';\n    }\n    doc.style.position = 'fixed';\n    doc.style.top = -scrollTop + 'px';\n    doc.style.overflow = 'hidden';\n    isOn = true;\n  }\n\n  function off() {\n    if (typeof document === 'undefined' || !isOn) return;\n    var doc = document.documentElement;\n    doc.style.width = '';\n    doc.style.position = '';\n    doc.style.top = '';\n    doc.style.overflow = '';\n    window.scroll(0, scrollTop);\n    isOn = false;\n  }\n\n  function toggle() {\n    if (isOn) {\n      off();\n      return;\n    }\n    on();\n  }\n\n  var noScroll = {\n    on: on,\n    off: off,\n    toggle: toggle,\n  };\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = noScroll;\n  } else {\n    root.noScroll = noScroll;\n  }\n})(this);\n","const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nconst isContentEditable = function (node) {\n  return node.contentEditable === 'true';\n};\n\nconst getTabindex = function (node) {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  if (\n    (node.nodeName === 'AUDIO' ||\n      node.nodeName === 'VIDEO' ||\n      node.nodeName === 'DETAILS') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isHidden = function (node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    const { width, height } = node.getBoundingClientRect();\n    return width === 0 && height === 0;\n  }\n\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (\n    isInput(node) ||\n    node.tagName === 'SELECT' ||\n    node.tagName === 'TEXTAREA' ||\n    node.tagName === 'BUTTON'\n  ) {\n    let parentNode = node.parentElement;\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            }\n\n            // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n            return true;\n          }\n        }\n\n        // the node isn't in a legend, so no matter where it is now, it'll be disabled\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options.displayCheck) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    !isNodeMatchingSelectorFocusable(options, node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  const regularTabbables = [];\n  const orderedTabbables = [];\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorTabbable.bind(null, options)\n  );\n\n  candidates.forEach(function (candidate, i) {\n    const candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  });\n\n  const tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorFocusable.bind(null, options)\n  );\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n","import { tabbable, isFocusable } from 'tabbable';\n\nconst activeFocusTraps = (function () {\n  const trapQueue = [];\n  return {\n    activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        const activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap(trap) {\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    },\n  };\n})();\n\nconst isSelectableInput = function (node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\nconst isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nconst isTabEvent = function (e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nconst delay = function (fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nconst findIndex = function (arr, fn) {\n  let idx = -1;\n\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nconst valueOrHandler = function (value, ...params) {\n  return typeof value === 'function' ? value(...params) : value;\n};\n\nconst getActualTarget = function (event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function'\n    ? event.composedPath()[0]\n    : event.target;\n};\n\nconst createFocusTrap = function (elements, userOptions) {\n  const doc = userOptions?.document || document;\n\n  const config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    ...userOptions,\n  };\n\n  const state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}\n    tabbableGroups: [],\n\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n  };\n\n  let trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  const getOption = (configOverrideOptions, optionName, configOptionName) => {\n    return configOverrideOptions &&\n      configOverrideOptions[optionName] !== undefined\n      ? configOverrideOptions[optionName]\n      : config[configOptionName || optionName];\n  };\n\n  const containersContain = function (element) {\n    return !!(\n      element &&\n      state.containers.some((container) => container.contains(element))\n    );\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  const getNodeForOption = function (optionName, ...params) {\n    let optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue(...params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\n        `\\`${optionName}\\` was specified but was not a node, or did not return a node`\n      );\n    }\n\n    let node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\n          `\\`${optionName}\\` as selector refers to no known node`\n        );\n      }\n    }\n\n    return node;\n  };\n\n  const getInitialFocusNode = function () {\n    let node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        const firstTabbableGroup = state.tabbableGroups[0];\n        const firstTabbableNode =\n          firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  };\n\n  const updateTabbableNodes = function () {\n    state.tabbableGroups = state.containers\n      .map((container) => {\n        const tabbableNodes = tabbable(container);\n\n        if (tabbableNodes.length > 0) {\n          return {\n            container,\n            firstTabbableNode: tabbableNodes[0],\n            lastTabbableNode: tabbableNodes[tabbableNodes.length - 1],\n          };\n        }\n\n        return undefined;\n      })\n      .filter((group) => !!group); // remove groups with no tabbable nodes\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (\n      state.tabbableGroups.length <= 0 &&\n      !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error(\n        'Your focus-trap must have at least one container with at least one tabbable node in it at all times'\n      );\n    }\n  };\n\n  const tryFocus = function (node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({ preventScroll: !!config.preventScroll });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  const getReturnFocusNode = function (previousActiveElement) {\n    const node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  const checkPointerDown = function (e) {\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target),\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  const checkFocusIn = function (e) {\n    const target = getActualTarget(e);\n    const targetContained = containersContain(target);\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  const checkTab = function (e) {\n    const target = getActualTarget(e);\n    updateTabbableNodes();\n\n    let destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's tabbable\n      //  with tabIndex='-1' and was given initial focus\n      const containerIndex = findIndex(state.tabbableGroups, ({ container }) =>\n        container.contains(target)\n      );\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode =\n            state.tabbableGroups[state.tabbableGroups.length - 1]\n              .lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        let startOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ firstTabbableNode }) => target === firstTabbableNode\n        );\n\n        if (\n          startOfGroupIndex < 0 &&\n          state.tabbableGroups[containerIndex].container === target\n        ) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          const destinationGroupIndex =\n            startOfGroupIndex === 0\n              ? state.tabbableGroups.length - 1\n              : startOfGroupIndex - 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        let lastOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ lastTabbableNode }) => target === lastTabbableNode\n        );\n\n        if (\n          lastOfGroupIndex < 0 &&\n          state.tabbableGroups[containerIndex].container === target\n        ) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          const destinationGroupIndex =\n            lastOfGroupIndex === state.tabbableGroups.length - 1\n              ? 0\n              : lastOfGroupIndex + 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  const checkKey = function (e) {\n    if (\n      isEscapeEvent(e) &&\n      valueOrHandler(config.escapeDeactivates, e) !== false\n    ) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  const checkClick = function (e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  const addListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  };\n\n  const removeListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      const onActivate = getOption(activateOptions, 'onActivate');\n      const onPostActivate = getOption(activateOptions, 'onPostActivate');\n      const checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      const finishActivation = () => {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(\n          finishActivation,\n          finishActivation\n        );\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n\n    deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n\n      activeFocusTraps.deactivateTrap(trap);\n\n      const onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      const onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      const checkCanReturnFocus = getOption(\n        deactivateOptions,\n        'checkCanReturnFocus'\n      );\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      const returnFocus = getOption(\n        deactivateOptions,\n        'returnFocus',\n        'returnFocusOnDeactivate'\n      );\n\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(\n          getReturnFocusNode(state.nodeFocusedBeforeActivation)\n        ).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n\n    pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n\n      return this;\n    },\n\n    unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n\n      return this;\n    },\n\n    updateContainerElements(containerElements) {\n      const elementsAsArray = [].concat(containerElements).filter(Boolean);\n\n      state.containers = elementsAsArray.map((element) =>\n        typeof element === 'string' ? doc.querySelector(element) : element\n      );\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    },\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n\n  return trap;\n};\n\nexport { createFocusTrap };\n"],"sourceRoot":""}